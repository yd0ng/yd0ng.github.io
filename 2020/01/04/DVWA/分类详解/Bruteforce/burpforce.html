<h1 id="Low"><a href="#Low" class="headerlink" title="Low"></a>Low</h1><pre><code>&lt;?php

if( isset( $_GET[ &apos;Login&apos; ] ) ) {
    // Get username
    $user = $_GET[ &apos;username&apos; ];

    // Get password
    $pass = $_GET[ &apos;password&apos; ];
    $pass = md5( $pass );

    // Check the database
    $query  = &quot;SELECT * FROM `users` WHERE user = &apos;$user&apos; AND password = &apos;$pass&apos;;&quot;;
    $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;],  $query ) or die( &apos;&lt;pre&gt;&apos; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &apos;&lt;/pre&gt;&apos; );

    if( $result &amp;&amp; mysqli_num_rows( $result ) == 1 ) {
        // Get users details
        $row    = mysqli_fetch_assoc( $result );
        $avatar = $row[&quot;avatar&quot;];

        // Login successful
        echo &quot;&lt;p&gt;Welcome to the password protected area {$user}&lt;/p&gt;&quot;;
        echo &quot;&lt;img src=\&quot;{$avatar}\&quot; /&gt;&quot;;
    }
    else {
        // Login failed
        echo &quot;&lt;pre&gt;&lt;br /&gt;Username and/or password incorrect.&lt;/pre&gt;&quot;;
    }

    ((is_null($___mysqli_res = mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]))) ? false : $___mysqli_res);
}

?&gt; </code></pre><p>发现对Login和pass参数未进行任何严格的检查与过滤，也没有设置防爆破机制</p>
<p>因为可以通过sql注入和爆破来进行强制登录</p>
<p>先利用Sql注入进行登录</p>
<pre><code>admin&apos; or &apos;1&apos;=&apos;1
admin&apos; #</code></pre><p>第一种情况将验证语句篡改为了user=’admin’ or ‘1’=’1’ and password = ‘$pass’;,因此不管密码为什么，整个语句的值恒为True，与下图原理类似</p>
<p><img src="assets%5C1554121537488.png" alt="1554121537488"></p>
<p><img src="assets%5C1554121291426.png" alt="1554121291426"></p>
<p>第二种直接将后面的and password = ‘$pass’;注释掉了，user=admin为True，因此表达式为True</p>
<p><img src="assets%5C1554121703523.png" alt="1554121703523"></p>
<p>爆破密码进行登录</p>
<p><img src="assets%5C1554120754439.png" alt="1554120754439"></p>
<p>抓包得到数据，右键send to the Intruder（爆破板块）</p>
<p><img src="assets%5C1554120817705.png" alt="1554120817705"></p>
<p>设置password 的值为爆破点，payload里加载密码字典</p>
<p>（这里要说明一下，爆破的原理还是穷举法，因此要不断积累自己的字典，理论上来讲，只要字典足够大，密码一定会被破开；同样，密码强度如果足够强，可以很大程度的保证自己的密码不被爆破破解）</p>
<p>加载字典完成后可以在option里更改爆破进程数</p>
<p><img src="assets%5C1554121018645.png" alt="1554121018645"></p>
<p>以上工作做好后点击Start attack 开始爆破</p>
<p><img src="assets%5C1554121062807.png" alt="1554121062807"></p>
<p>密码爆破的特征是正确密码的放回长度与错误密码不一样，这里很容易发现password为正确密码</p>
<p><img src="assets%5C1554121156376.png" alt="1554121156376"></p>
<p>验证成功，密码为password</p>
<h1 id="Medium"><a href="#Medium" class="headerlink" title="Medium"></a>Medium</h1><pre><code>&lt;?php

if( isset( $_GET[ &apos;Login&apos; ] ) ) {
    // Sanitise username input
    $user = $_GET[ &apos;username&apos; ];
    $user = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;],  $user ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;));

    // Sanitise password input
    $pass = $_GET[ &apos;password&apos; ];
    $pass = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;],  $pass ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;));
    $pass = md5( $pass );

    // Check the database
    $query  = &quot;SELECT * FROM `users` WHERE user = &apos;$user&apos; AND password = &apos;$pass&apos;;&quot;;
    $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;],  $query ) or die( &apos;&lt;pre&gt;&apos; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &apos;&lt;/pre&gt;&apos; );

    if( $result &amp;&amp; mysqli_num_rows( $result ) == 1 ) {
        // Get users details
        $row    = mysqli_fetch_assoc( $result );
        $avatar = $row[&quot;avatar&quot;];

        // Login successful
        echo &quot;&lt;p&gt;Welcome to the password protected area {$user}&lt;/p&gt;&quot;;
        echo &quot;&lt;img src=\&quot;{$avatar}\&quot; /&gt;&quot;;
    }
    else {
        // Login failed
        sleep( 2 );
        echo &quot;&lt;pre&gt;&lt;br /&gt;Username and/or password incorrect.&lt;/pre&gt;&quot;;
    }

    ((is_null($___mysqli_res = mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]))) ? false : $___mysqli_res);
}

?&gt; </code></pre><p>很明显发现多了mysqli_real_escape_string这个函数，让我们来看一下这个函数的作用</p>
<p><img src="assets%5C1554121913927.png" alt="1554121913927"></p>
<p>也就是说将我们sql注入中的许多常用字符都给过滤掉了，这样基本杜绝了sql注入（相信一切输入都是有害的）</p>
<p>但是我们发现代码并没有加上严格的防爆破机制，因为爆破密码仍然有效，爆破方法与刚才相同，不再赘述。</p>
<h1 id="High"><a href="#High" class="headerlink" title="High"></a>High</h1><pre><code>&lt;?php

if( isset( $_GET[ &apos;Login&apos; ] ) ) {
    // Check Anti-CSRF token
    checkToken( $_REQUEST[ &apos;user_token&apos; ], $_SESSION[ &apos;session_token&apos; ], &apos;index.php&apos; );

    // Sanitise username input
    $user = $_GET[ &apos;username&apos; ];
    $user = stripslashes( $user );
    $user = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;],  $user ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;));

    // Sanitise password input
    $pass = $_GET[ &apos;password&apos; ];
    $pass = stripslashes( $pass );
    $pass = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;],  $pass ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;));
    $pass = md5( $pass );

    // Check database
    $query  = &quot;SELECT * FROM `users` WHERE user = &apos;$user&apos; AND password = &apos;$pass&apos;;&quot;;
    $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;],  $query ) or die( &apos;&lt;pre&gt;&apos; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &apos;&lt;/pre&gt;&apos; );

    if( $result &amp;&amp; mysqli_num_rows( $result ) == 1 ) {
        // Get users details
        $row    = mysqli_fetch_assoc( $result );
        $avatar = $row[&quot;avatar&quot;];

        // Login successful
        echo &quot;&lt;p&gt;Welcome to the password protected area {$user}&lt;/p&gt;&quot;;
        echo &quot;&lt;img src=\&quot;{$avatar}\&quot; /&gt;&quot;;
    }
    else {
        // Login failed
        sleep( rand( 0, 3 ) );
        echo &quot;&lt;pre&gt;&lt;br /&gt;Username and/or password incorrect.&lt;/pre&gt;&quot;;
    }

    ((is_null($___mysqli_res = mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]))) ? false : $___mysqli_res);
}

// Generate Anti-CSRF token
generateSessionToken();

?&gt; </code></pre><p>我们发现在high等级的防护上加入了CSRF-token机制</p>
<p>CSRF-token机制：在访问页面时，服务器会在给本地浏览器一个token随机数，用户输入账号密码点击提交时，token会与user与password一同在服务器端进行验证，如果token不对，直接拒绝服务</p>
<p>因为每次的token是不同的，因为理论上这样似乎是能够防御爆破的，但是实际上，如果我们能够获取到在每次登陆界面的token值，我们就仍然可以进行爆破</p>
<p><img src="assets%5C1554122345042.png" alt="1554122345042"></p>
<p>我们观察发现，在login.php界面，token被放在了这样一个form表单里</p>
<p>token值的前面是   <code>value=‘</code></p>
<p>token值的后面是   <code>&#39; /&gt;&lt;/form&gt;</code></p>
<p>我们可以通过burpsuite的正则过滤来匹配这个特征，从而得到token值，下面进行操作</p>
<p>首先，抓包并send to Intruder</p>
<p><img src="assets%5C1554122573732.png" alt="1554122573732"></p>
<p>更改Attack type为Pitchfork，并标记password和user_token为两个爆破点</p>
<p>（Pitchfork：草叉模式，对不同参数设置不用的payload）</p>
<p><img src="assets%5C1554122625239.png" alt="1554122625239"></p>
<p>在option里，更改线程为1（Pitchfork不支持多线程爆破),点击Grep-Extract的Add，添加我们要匹配的模式</p>
<p><img src="assets%5C1554122899405.png" alt="1554122899405"></p>
<p>点击OK后，将option页面最下面的Redirections改为Always（保证每次使用的user_token为最新的）</p>
<p>在Payloads页面中设置两个爆破点的payload</p>
<p><img src="assets%5C1554123009896.png" alt="1554123009896"></p>
<p>注意参数2的payload type 为Recursive grep</p>
<p><img src="assets%5C1554123027531.png" alt="1554123027531"></p>
<p>上述操作全部完成后，Start attack</p>
<p>因为为单线程，所以速度可能有点慢</p>
<p><img src="assets%5C1554123101661.png" alt="1554123101661"></p>
<p>爆破成功，得到密码为password</p>
<h1 id="Impossible"><a href="#Impossible" class="headerlink" title="Impossible"></a>Impossible</h1><pre><code>&lt;?php

if( isset( $_POST[ &apos;Login&apos; ] ) &amp;&amp; isset ($_POST[&apos;username&apos;]) &amp;&amp; isset ($_POST[&apos;password&apos;]) ) {
    // Check Anti-CSRF token
    checkToken( $_REQUEST[ &apos;user_token&apos; ], $_SESSION[ &apos;session_token&apos; ], &apos;index.php&apos; );

    // Sanitise username input
    $user = $_POST[ &apos;username&apos; ];
    $user = stripslashes( $user );
    $user = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;],  $user ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;));

    // Sanitise password input
    $pass = $_POST[ &apos;password&apos; ];
    $pass = stripslashes( $pass );
    $pass = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;],  $pass ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;));
    $pass = md5( $pass );

    // Default values
    $total_failed_login = 3;
    $lockout_time       = 15;
    $account_locked     = false;

    // Check the database (Check user information)
    $data = $db-&gt;prepare( &apos;SELECT failed_login, last_login FROM users WHERE user = (:user) LIMIT 1;&apos; );
    $data-&gt;bindParam( &apos;:user&apos;, $user, PDO::PARAM_STR );
    $data-&gt;execute();
    $row = $data-&gt;fetch();

    // Check to see if the user has been locked out.
    if( ( $data-&gt;rowCount() == 1 ) &amp;&amp; ( $row[ &apos;failed_login&apos; ] &gt;= $total_failed_login ) )  {
        // User locked out.  Note, using this method would allow for user enumeration!
        //echo &quot;&lt;pre&gt;&lt;br /&gt;This account has been locked due to too many incorrect logins.&lt;/pre&gt;&quot;;

        // Calculate when the user would be allowed to login again
        $last_login = strtotime( $row[ &apos;last_login&apos; ] );
        $timeout    = $last_login + ($lockout_time * 60);
        $timenow    = time();

        /*
        print &quot;The last login was: &quot; . date (&quot;h:i:s&quot;, $last_login) . &quot;&lt;br /&gt;&quot;;
        print &quot;The timenow is: &quot; . date (&quot;h:i:s&quot;, $timenow) . &quot;&lt;br /&gt;&quot;;
        print &quot;The timeout is: &quot; . date (&quot;h:i:s&quot;, $timeout) . &quot;&lt;br /&gt;&quot;;
        */

        // Check to see if enough time has passed, if it hasn&apos;t locked the account
        if( $timenow &lt; $timeout ) {
            $account_locked = true;
            // print &quot;The account is locked&lt;br /&gt;&quot;;
        }
    }

    // Check the database (if username matches the password)
    $data = $db-&gt;prepare( &apos;SELECT * FROM users WHERE user = (:user) AND password = (:password) LIMIT 1;&apos; );
    $data-&gt;bindParam( &apos;:user&apos;, $user, PDO::PARAM_STR);
    $data-&gt;bindParam( &apos;:password&apos;, $pass, PDO::PARAM_STR );
    $data-&gt;execute();
    $row = $data-&gt;fetch();

    // If its a valid login...
    if( ( $data-&gt;rowCount() == 1 ) &amp;&amp; ( $account_locked == false ) ) {
        // Get users details
        $avatar       = $row[ &apos;avatar&apos; ];
        $failed_login = $row[ &apos;failed_login&apos; ];
        $last_login   = $row[ &apos;last_login&apos; ];

        // Login successful
        echo &quot;&lt;p&gt;Welcome to the password protected area &lt;em&gt;{$user}&lt;/em&gt;&lt;/p&gt;&quot;;
        echo &quot;&lt;img src=\&quot;{$avatar}\&quot; /&gt;&quot;;

        // Had the account been locked out since last login?
        if( $failed_login &gt;= $total_failed_login ) {
            echo &quot;&lt;p&gt;&lt;em&gt;Warning&lt;/em&gt;: Someone might of been brute forcing your account.&lt;/p&gt;&quot;;
            echo &quot;&lt;p&gt;Number of login attempts: &lt;em&gt;{$failed_login}&lt;/em&gt;.&lt;br /&gt;Last login attempt was at: &lt;em&gt;${last_login}&lt;/em&gt;.&lt;/p&gt;&quot;;
        }

        // Reset bad login count
        $data = $db-&gt;prepare( &apos;UPDATE users SET failed_login = &quot;0&quot; WHERE user = (:user) LIMIT 1;&apos; );
        $data-&gt;bindParam( &apos;:user&apos;, $user, PDO::PARAM_STR );
        $data-&gt;execute();
    } else {
        // Login failed
        sleep( rand( 2, 4 ) );

        // Give the user some feedback
        echo &quot;&lt;pre&gt;&lt;br /&gt;Username and/or password incorrect.&lt;br /&gt;&lt;br/&gt;Alternative, the account has been locked because of too many failed logins.&lt;br /&gt;If this is the case, &lt;em&gt;please try again in {$lockout_time} minutes&lt;/em&gt;.&lt;/pre&gt;&quot;;

        // Update bad login count
        $data = $db-&gt;prepare( &apos;UPDATE users SET failed_login = (failed_login + 1) WHERE user = (:user) LIMIT 1;&apos; );
        $data-&gt;bindParam( &apos;:user&apos;, $user, PDO::PARAM_STR );
        $data-&gt;execute();
    }

    // Set the last login time
    $data = $db-&gt;prepare( &apos;UPDATE users SET last_login = now() WHERE user = (:user) LIMIT 1;&apos; );
    $data-&gt;bindParam( &apos;:user&apos;, $user, PDO::PARAM_STR );
    $data-&gt;execute();
}

// Generate Anti-CSRF token
generateSessionToken();

?&gt; </code></pre><p>在impossible级别里加入了防爆破机制，如果短时间内错误次数过多，将锁定账户，直接了当的解决了爆破问题</p>
